ABI 规定了桢栈结构：
下面以linux为例从三个方面说明：
1、栈帧的内存结构
2、栈帧的形成
3、栈帧的销毁

1、栈帧的内存结构
两个关键的寄存器，栈帧基地寄存器ebp和栈帧栈顶寄存器esp

高    内存地址    
 ^     ebp+8  :    
 |     ebp+4  :     返回地址，有call指令保存的eip
 |     ebp    :     上一个函数栈帧的ebp              
 |     ebp-4  :     局部变量1
 |     .    
 |     .
 |     .            局部变量n
 |     .            下一个被调用函数的最右边参数
 |     .            .
 |     .            .
低     esp          下一个被调用函数的最左边参数


2、栈帧的形成：主要两步、前言和后续
前言：
	1、将当前ebp寄存器的值，即上一个函数的ebp指针的地址压入栈  （注意：在这步时call调用这个函数已经将返回地址入栈保存了，栈帧是函数调用时形成的链式内存结构）
	2、将esp寄存器的值赋值给ebp寄存器，即改变ebp寄存器中的值，使其指向上面一步的栈帧地址，即被调用函数的ebp指向的是调用函数的ebp地址，当前函数的栈帧基址ebp也就形成了
	3、将esp指针减一个常量值，这个就是当前函数的栈帧大小了
	上面三步对应下面这三条汇编指令：
	push   %ebp
	mov    %esp,%ebp
	sub    $常量值,%esp
	
后序：
	1、leval对应的操作相当于是： mov %ebp, %esp;  pop %ebp
	   将esp寄存器的值置ebp寄存器的值，即将栈顶指针直接一下打到栈基址的位置，相当于退栈操作。
	   再pop弹栈，将栈顶指针的内容弹到ebp寄存器中，即将ebp寄出器重置指向了上一个函数的栈帧基址
	   经过上面两个操作后，当前函数的栈就被完全销毁了。同时弹栈操作使得此刻 栈顶指针esp指向了返回地址处，为下步准备
	2、ret 对应的操作相当于是：pop %pc 
	   将栈上栈顶指针指向(指向返回地址)的内容弹到pc指针中，这样函数就返回了!!!
	   同时esp就指向了上一个函数栈帧的栈顶了!
	leval
	ret
	
3、栈帧的销毁：对应上面的后序过程


