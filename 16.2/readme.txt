根据反汇编可以看到：
main()函数中：
	mov    0x804a020,%eax        // 是将内存地址0x804a020里面的内容，赋值给eax寄存器
	
define_print()函数中：
	movl   $0x804a020,0x4(%esp)  // 是将地址常量0x804a020 赋值给eax寄存器
	
上面就是差异，也就是造成段错误的根因：
在 define.c 的定义中是以数组的形式定义的，而 main.c 中又是以指针的方式引用的符合 g_name 的，所以就导致了上面的段错误问题：
以数组定义：内存地址0x804a020开始的连续内存空间内放的都是 "liyao test!",而main.c中确实将这个内存地址中的内容取出来再当做一个地址去用，就相当于是个野指针了，所以当然就会出现段错误！

上面是导致问题的原因，下面分析为什么会出现这种现象：
C/C++编译器的天生缺陷
	1、有4个子部件组成（预处理器、编译器、汇编器、链接器）
	2、每个子部件独立工作，相互之间没有通信
	3、语法规范只在编译阶段有效（如：类型约束、保护成员）
	4、编译器部件对各个源文件进行独立编译（认为源文件相互独立）

问题本质：
	1、编译器根据当前源码产生二进制代码，file.c到file.o的过程，如当前源码中声明的“指针”，则编译器按照指针方式编译（目标文件中的符合无类型信息）
	2、连接器中最终确定各个符合的地址，但各个符合没有类型信息，所以链接器是没有办法给出两个文件中同一个符合类型不一致的错误的！
	3、所以编译是没有报错，但执行时就段错误了！
	
解决方案：
	1、尽可能不使用跨文件的全局变量（非static全局变量）
	2、当必须使用时，在统一固定的头文件中声明（global.h）
	3、使用跨文件全局变量的源文件直接包含global.h
	4、定义跨文件全局变量的源文件也需要包含global.h
	
小贴士：声明和定义不同
	1、声明只是告诉编译器，目标存在，可使用
	2、定义实际为目标分配内存（变量）或确定执行流（函数）
	3、理论上，任何目标都需要先声明，再使用
	4、C/C++语言允许声明与定义的统一
	
小结：
	1、C/C++语言中的指针与数组在部分情况可等价
	2、指针与数组在二进制层面的操作完全不同
	3、C/C++编译器忽略了源码间的依赖关系
	4、在统一固定的头文件中声明跨文件使用的全局变量（global.h）
	5、使用跨文件全局变量的源文件中直接包含global.h