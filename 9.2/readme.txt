执行./main.out之后再执行 echo #? 可看到执行main.out的退出码为42，验证代码的正确性
在内嵌汇编实现 printf 和 exit 之间，在我当前平台上(ubuntu上)，需要加一定的延时，才会输出预期结果，否则，只能看到main begin的输出，根据现在猜测应该是还没等输出进程就退出了!但为什么会这样的原因还不知道 --- 记录个问题，后面回到！
解答这个问题：是因为传参中的长度写错，printf是行缓存，传的长度只没有算入\n，所以，就没有输出！
新问题：那为什么延时等待也没有 \n,缓存区也没满，为什么sleep(10),就立即有输出了呢？？？？


可选参数全部省略寄存器前只用 %，部分省略寄存器前必须要两个%%
原因：如果“可选参数”部分全部省略，则汇编退化为一个基本的内联汇编。此时寄存器前只需使用一个百分号（%）。否则，仍然是一个带有C/C++表达式的内联汇编，此时“汇编指令”中的寄存器写法要遵守相关规定，比如在寄存器前必须使用两个百分号（%）为作寄存器名称的前缀，因为其中前一个“%”在asm内嵌汇编语句中的作用与“\”在C语言中的作用相同，因此“%%”转换后代表“%”


c内嵌汇编的语法格式：

asm volatile(       // volatile 可选，写出表示禁止编译器对这个部分优化
	"汇编指令"      // 每条以 \n 分割
	:"=限制符"(输出参数)    // 输出寄存器与输出参数关联（可选）
	:"限制符"(输入参数)     // 输入寄存器与输入参数关联（可选）
	:保留寄存器列表         // 用于告诉编译器不要为“输入寄存器”和“输出寄存器”分配这些寄存器（可选）
);

备注：上面后面三部分全为可选参数


